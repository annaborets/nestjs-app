# Lesson 9 — Files Module

## What was done

- Integrated domain: **Users** (avatar upload)
- S3-compatible storage: **MinIO** (runs locally via Docker)
- New entity: `FileRecord` with statuses `pending` / `ready`

## How it works

### 1. Presign — `POST /files/presign`

Client sends `contentType`, `entityType`, and `entityId`. Backend:

- checks that the user can only upload for themselves
- generates a unique key (e.g. `users/1/avatars/uuid.jpeg`)
- creates a `FileRecord` with status `pending`
- returns a presigned URL for direct upload to S3

Request:

```json
{
  "contentType": "image/jpeg",
  "entityType": "user",
  "entityId": 1
}
```

Response:

```json
{
  "fileId": "uuid",
  "key": "users/1/avatars/uuid.jpeg",
  "uploadUrl": "http://localhost:9002/...",
  "contentType": "image/jpeg"
}
```

### 2. Upload — client → S3 directly

Client sends `PUT` request to `uploadUrl` with the file. Backend is not involved.

### 3. Complete — `POST /files/complete`

Client sends `fileId`. Backend:

- checks ownership (file belongs to this user)
- checks that file exists in S3
- updates status to `ready`
- links file to `User.avatarFileId`

Request:

```json
{
  "fileId": "uuid"
}
```

## Access checks

- All endpoints require JWT authentication
- User can only presign/complete files for their own `entityId`
- Key is generated by backend — client cannot choose file path
- Bucket is private (`mc anonymous set none`)

## File URL

Files are accessible via: `CLOUDFRONT_BASE_URL + key`

In dev: `http://localhost:9002/lesson9-files-private/users/1/avatars/uuid.jpeg`

## How to run

```bash
docker compose up -d
npm run start:dev
```

Copy `.env.example` to `.env.local` and fill in the values.

MinIO dashboard: http://localhost:9001
